// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/eclipse-xfsc/task-sheduler/internal/service"
)

type FakeQueue struct {
	AckStub        func(context.Context, *service.Task) error
	ackMutex       sync.RWMutex
	ackArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Task
	}
	ackReturns struct {
		result1 error
	}
	ackReturnsOnCall map[int]struct {
		result1 error
	}
	AckGroupTasksStub        func(context.Context, *service.Group) error
	ackGroupTasksMutex       sync.RWMutex
	ackGroupTasksArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Group
	}
	ackGroupTasksReturns struct {
		result1 error
	}
	ackGroupTasksReturnsOnCall map[int]struct {
		result1 error
	}
	AckListStub        func(context.Context, *service.TaskList) error
	ackListMutex       sync.RWMutex
	ackListArgsForCall []struct {
		arg1 context.Context
		arg2 *service.TaskList
	}
	ackListReturns struct {
		result1 error
	}
	ackListReturnsOnCall map[int]struct {
		result1 error
	}
	AddStub        func(context.Context, *service.Task) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Task
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	AddTaskListStub        func(context.Context, *service.TaskList, []*service.Task) error
	addTaskListMutex       sync.RWMutex
	addTaskListArgsForCall []struct {
		arg1 context.Context
		arg2 *service.TaskList
		arg3 []*service.Task
	}
	addTaskListReturns struct {
		result1 error
	}
	addTaskListReturnsOnCall map[int]struct {
		result1 error
	}
	PollStub        func(context.Context) (*service.Task, error)
	pollMutex       sync.RWMutex
	pollArgsForCall []struct {
		arg1 context.Context
	}
	pollReturns struct {
		result1 *service.Task
		result2 error
	}
	pollReturnsOnCall map[int]struct {
		result1 *service.Task
		result2 error
	}
	PollListStub        func(context.Context) (*service.TaskList, error)
	pollListMutex       sync.RWMutex
	pollListArgsForCall []struct {
		arg1 context.Context
	}
	pollListReturns struct {
		result1 *service.TaskList
		result2 error
	}
	pollListReturnsOnCall map[int]struct {
		result1 *service.TaskList
		result2 error
	}
	UnackStub        func(context.Context, *service.Task) error
	unackMutex       sync.RWMutex
	unackArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Task
	}
	unackReturns struct {
		result1 error
	}
	unackReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueue) Ack(arg1 context.Context, arg2 *service.Task) error {
	fake.ackMutex.Lock()
	ret, specificReturn := fake.ackReturnsOnCall[len(fake.ackArgsForCall)]
	fake.ackArgsForCall = append(fake.ackArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Task
	}{arg1, arg2})
	stub := fake.AckStub
	fakeReturns := fake.ackReturns
	fake.recordInvocation("Ack", []interface{}{arg1, arg2})
	fake.ackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) AckCallCount() int {
	fake.ackMutex.RLock()
	defer fake.ackMutex.RUnlock()
	return len(fake.ackArgsForCall)
}

func (fake *FakeQueue) AckCalls(stub func(context.Context, *service.Task) error) {
	fake.ackMutex.Lock()
	defer fake.ackMutex.Unlock()
	fake.AckStub = stub
}

func (fake *FakeQueue) AckArgsForCall(i int) (context.Context, *service.Task) {
	fake.ackMutex.RLock()
	defer fake.ackMutex.RUnlock()
	argsForCall := fake.ackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueue) AckReturns(result1 error) {
	fake.ackMutex.Lock()
	defer fake.ackMutex.Unlock()
	fake.AckStub = nil
	fake.ackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AckReturnsOnCall(i int, result1 error) {
	fake.ackMutex.Lock()
	defer fake.ackMutex.Unlock()
	fake.AckStub = nil
	if fake.ackReturnsOnCall == nil {
		fake.ackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AckGroupTasks(arg1 context.Context, arg2 *service.Group) error {
	fake.ackGroupTasksMutex.Lock()
	ret, specificReturn := fake.ackGroupTasksReturnsOnCall[len(fake.ackGroupTasksArgsForCall)]
	fake.ackGroupTasksArgsForCall = append(fake.ackGroupTasksArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Group
	}{arg1, arg2})
	stub := fake.AckGroupTasksStub
	fakeReturns := fake.ackGroupTasksReturns
	fake.recordInvocation("AckGroupTasks", []interface{}{arg1, arg2})
	fake.ackGroupTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) AckGroupTasksCallCount() int {
	fake.ackGroupTasksMutex.RLock()
	defer fake.ackGroupTasksMutex.RUnlock()
	return len(fake.ackGroupTasksArgsForCall)
}

func (fake *FakeQueue) AckGroupTasksCalls(stub func(context.Context, *service.Group) error) {
	fake.ackGroupTasksMutex.Lock()
	defer fake.ackGroupTasksMutex.Unlock()
	fake.AckGroupTasksStub = stub
}

func (fake *FakeQueue) AckGroupTasksArgsForCall(i int) (context.Context, *service.Group) {
	fake.ackGroupTasksMutex.RLock()
	defer fake.ackGroupTasksMutex.RUnlock()
	argsForCall := fake.ackGroupTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueue) AckGroupTasksReturns(result1 error) {
	fake.ackGroupTasksMutex.Lock()
	defer fake.ackGroupTasksMutex.Unlock()
	fake.AckGroupTasksStub = nil
	fake.ackGroupTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AckGroupTasksReturnsOnCall(i int, result1 error) {
	fake.ackGroupTasksMutex.Lock()
	defer fake.ackGroupTasksMutex.Unlock()
	fake.AckGroupTasksStub = nil
	if fake.ackGroupTasksReturnsOnCall == nil {
		fake.ackGroupTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ackGroupTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AckList(arg1 context.Context, arg2 *service.TaskList) error {
	fake.ackListMutex.Lock()
	ret, specificReturn := fake.ackListReturnsOnCall[len(fake.ackListArgsForCall)]
	fake.ackListArgsForCall = append(fake.ackListArgsForCall, struct {
		arg1 context.Context
		arg2 *service.TaskList
	}{arg1, arg2})
	stub := fake.AckListStub
	fakeReturns := fake.ackListReturns
	fake.recordInvocation("AckList", []interface{}{arg1, arg2})
	fake.ackListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) AckListCallCount() int {
	fake.ackListMutex.RLock()
	defer fake.ackListMutex.RUnlock()
	return len(fake.ackListArgsForCall)
}

func (fake *FakeQueue) AckListCalls(stub func(context.Context, *service.TaskList) error) {
	fake.ackListMutex.Lock()
	defer fake.ackListMutex.Unlock()
	fake.AckListStub = stub
}

func (fake *FakeQueue) AckListArgsForCall(i int) (context.Context, *service.TaskList) {
	fake.ackListMutex.RLock()
	defer fake.ackListMutex.RUnlock()
	argsForCall := fake.ackListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueue) AckListReturns(result1 error) {
	fake.ackListMutex.Lock()
	defer fake.ackListMutex.Unlock()
	fake.AckListStub = nil
	fake.ackListReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AckListReturnsOnCall(i int, result1 error) {
	fake.ackListMutex.Lock()
	defer fake.ackListMutex.Unlock()
	fake.AckListStub = nil
	if fake.ackListReturnsOnCall == nil {
		fake.ackListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ackListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) Add(arg1 context.Context, arg2 *service.Task) error {
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Task
	}{arg1, arg2})
	stub := fake.AddStub
	fakeReturns := fake.addReturns
	fake.recordInvocation("Add", []interface{}{arg1, arg2})
	fake.addMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeQueue) AddCalls(stub func(context.Context, *service.Task) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeQueue) AddArgsForCall(i int) (context.Context, *service.Task) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueue) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AddTaskList(arg1 context.Context, arg2 *service.TaskList, arg3 []*service.Task) error {
	var arg3Copy []*service.Task
	if arg3 != nil {
		arg3Copy = make([]*service.Task, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addTaskListMutex.Lock()
	ret, specificReturn := fake.addTaskListReturnsOnCall[len(fake.addTaskListArgsForCall)]
	fake.addTaskListArgsForCall = append(fake.addTaskListArgsForCall, struct {
		arg1 context.Context
		arg2 *service.TaskList
		arg3 []*service.Task
	}{arg1, arg2, arg3Copy})
	stub := fake.AddTaskListStub
	fakeReturns := fake.addTaskListReturns
	fake.recordInvocation("AddTaskList", []interface{}{arg1, arg2, arg3Copy})
	fake.addTaskListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) AddTaskListCallCount() int {
	fake.addTaskListMutex.RLock()
	defer fake.addTaskListMutex.RUnlock()
	return len(fake.addTaskListArgsForCall)
}

func (fake *FakeQueue) AddTaskListCalls(stub func(context.Context, *service.TaskList, []*service.Task) error) {
	fake.addTaskListMutex.Lock()
	defer fake.addTaskListMutex.Unlock()
	fake.AddTaskListStub = stub
}

func (fake *FakeQueue) AddTaskListArgsForCall(i int) (context.Context, *service.TaskList, []*service.Task) {
	fake.addTaskListMutex.RLock()
	defer fake.addTaskListMutex.RUnlock()
	argsForCall := fake.addTaskListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueue) AddTaskListReturns(result1 error) {
	fake.addTaskListMutex.Lock()
	defer fake.addTaskListMutex.Unlock()
	fake.AddTaskListStub = nil
	fake.addTaskListReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) AddTaskListReturnsOnCall(i int, result1 error) {
	fake.addTaskListMutex.Lock()
	defer fake.addTaskListMutex.Unlock()
	fake.AddTaskListStub = nil
	if fake.addTaskListReturnsOnCall == nil {
		fake.addTaskListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addTaskListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) Poll(arg1 context.Context) (*service.Task, error) {
	fake.pollMutex.Lock()
	ret, specificReturn := fake.pollReturnsOnCall[len(fake.pollArgsForCall)]
	fake.pollArgsForCall = append(fake.pollArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PollStub
	fakeReturns := fake.pollReturns
	fake.recordInvocation("Poll", []interface{}{arg1})
	fake.pollMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueue) PollCallCount() int {
	fake.pollMutex.RLock()
	defer fake.pollMutex.RUnlock()
	return len(fake.pollArgsForCall)
}

func (fake *FakeQueue) PollCalls(stub func(context.Context) (*service.Task, error)) {
	fake.pollMutex.Lock()
	defer fake.pollMutex.Unlock()
	fake.PollStub = stub
}

func (fake *FakeQueue) PollArgsForCall(i int) context.Context {
	fake.pollMutex.RLock()
	defer fake.pollMutex.RUnlock()
	argsForCall := fake.pollArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueue) PollReturns(result1 *service.Task, result2 error) {
	fake.pollMutex.Lock()
	defer fake.pollMutex.Unlock()
	fake.PollStub = nil
	fake.pollReturns = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeQueue) PollReturnsOnCall(i int, result1 *service.Task, result2 error) {
	fake.pollMutex.Lock()
	defer fake.pollMutex.Unlock()
	fake.PollStub = nil
	if fake.pollReturnsOnCall == nil {
		fake.pollReturnsOnCall = make(map[int]struct {
			result1 *service.Task
			result2 error
		})
	}
	fake.pollReturnsOnCall[i] = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeQueue) PollList(arg1 context.Context) (*service.TaskList, error) {
	fake.pollListMutex.Lock()
	ret, specificReturn := fake.pollListReturnsOnCall[len(fake.pollListArgsForCall)]
	fake.pollListArgsForCall = append(fake.pollListArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PollListStub
	fakeReturns := fake.pollListReturns
	fake.recordInvocation("PollList", []interface{}{arg1})
	fake.pollListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueue) PollListCallCount() int {
	fake.pollListMutex.RLock()
	defer fake.pollListMutex.RUnlock()
	return len(fake.pollListArgsForCall)
}

func (fake *FakeQueue) PollListCalls(stub func(context.Context) (*service.TaskList, error)) {
	fake.pollListMutex.Lock()
	defer fake.pollListMutex.Unlock()
	fake.PollListStub = stub
}

func (fake *FakeQueue) PollListArgsForCall(i int) context.Context {
	fake.pollListMutex.RLock()
	defer fake.pollListMutex.RUnlock()
	argsForCall := fake.pollListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueue) PollListReturns(result1 *service.TaskList, result2 error) {
	fake.pollListMutex.Lock()
	defer fake.pollListMutex.Unlock()
	fake.PollListStub = nil
	fake.pollListReturns = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeQueue) PollListReturnsOnCall(i int, result1 *service.TaskList, result2 error) {
	fake.pollListMutex.Lock()
	defer fake.pollListMutex.Unlock()
	fake.PollListStub = nil
	if fake.pollListReturnsOnCall == nil {
		fake.pollListReturnsOnCall = make(map[int]struct {
			result1 *service.TaskList
			result2 error
		})
	}
	fake.pollListReturnsOnCall[i] = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeQueue) Unack(arg1 context.Context, arg2 *service.Task) error {
	fake.unackMutex.Lock()
	ret, specificReturn := fake.unackReturnsOnCall[len(fake.unackArgsForCall)]
	fake.unackArgsForCall = append(fake.unackArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Task
	}{arg1, arg2})
	stub := fake.UnackStub
	fakeReturns := fake.unackReturns
	fake.recordInvocation("Unack", []interface{}{arg1, arg2})
	fake.unackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueue) UnackCallCount() int {
	fake.unackMutex.RLock()
	defer fake.unackMutex.RUnlock()
	return len(fake.unackArgsForCall)
}

func (fake *FakeQueue) UnackCalls(stub func(context.Context, *service.Task) error) {
	fake.unackMutex.Lock()
	defer fake.unackMutex.Unlock()
	fake.UnackStub = stub
}

func (fake *FakeQueue) UnackArgsForCall(i int) (context.Context, *service.Task) {
	fake.unackMutex.RLock()
	defer fake.unackMutex.RUnlock()
	argsForCall := fake.unackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueue) UnackReturns(result1 error) {
	fake.unackMutex.Lock()
	defer fake.unackMutex.Unlock()
	fake.UnackStub = nil
	fake.unackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) UnackReturnsOnCall(i int, result1 error) {
	fake.unackMutex.Lock()
	defer fake.unackMutex.Unlock()
	fake.UnackStub = nil
	if fake.unackReturnsOnCall == nil {
		fake.unackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQueue) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.ackMutex.RLock()
	defer fake.ackMutex.RUnlock()
	fake.ackGroupTasksMutex.RLock()
	defer fake.ackGroupTasksMutex.RUnlock()
	fake.ackListMutex.RLock()
	defer fake.ackListMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.addTaskListMutex.RLock()
	defer fake.addTaskListMutex.RUnlock()
	fake.pollMutex.RLock()
	defer fake.pollMutex.RUnlock()
	fake.pollListMutex.RLock()
	defer fake.pollListMutex.RUnlock()
	fake.unackMutex.RLock()
	defer fake.unackMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueue) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.Queue = new(FakeQueue)
