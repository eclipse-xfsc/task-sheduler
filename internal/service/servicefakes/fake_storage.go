// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/eclipse-xfsc/task-sheduler/internal/service"
)

type FakeStorage struct {
	EventTaskStub        func(context.Context, string, string, string) (*service.EventTask, error)
	eventTaskMutex       sync.RWMutex
	eventTaskArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	eventTaskReturns struct {
		result1 *service.EventTask
		result2 error
	}
	eventTaskReturnsOnCall map[int]struct {
		result1 *service.EventTask
		result2 error
	}
	GetGroupTasksStub        func(context.Context, *service.Group) ([]*service.Task, error)
	getGroupTasksMutex       sync.RWMutex
	getGroupTasksArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Group
	}
	getGroupTasksReturns struct {
		result1 []*service.Task
		result2 error
	}
	getGroupTasksReturnsOnCall map[int]struct {
		result1 []*service.Task
		result2 error
	}
	SaveTaskHistoryStub        func(context.Context, *service.Task) error
	saveTaskHistoryMutex       sync.RWMutex
	saveTaskHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 *service.Task
	}
	saveTaskHistoryReturns struct {
		result1 error
	}
	saveTaskHistoryReturnsOnCall map[int]struct {
		result1 error
	}
	SaveTaskListHistoryStub        func(context.Context, *service.TaskList) error
	saveTaskListHistoryMutex       sync.RWMutex
	saveTaskListHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 *service.TaskList
	}
	saveTaskListHistoryReturns struct {
		result1 error
	}
	saveTaskListHistoryReturnsOnCall map[int]struct {
		result1 error
	}
	TaskStub        func(context.Context, string) (*service.Task, error)
	taskMutex       sync.RWMutex
	taskArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskReturns struct {
		result1 *service.Task
		result2 error
	}
	taskReturnsOnCall map[int]struct {
		result1 *service.Task
		result2 error
	}
	TaskHistoryStub        func(context.Context, string) (*service.Task, error)
	taskHistoryMutex       sync.RWMutex
	taskHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskHistoryReturns struct {
		result1 *service.Task
		result2 error
	}
	taskHistoryReturnsOnCall map[int]struct {
		result1 *service.Task
		result2 error
	}
	TaskListStub        func(context.Context, string) (*service.TaskList, error)
	taskListMutex       sync.RWMutex
	taskListArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskListReturns struct {
		result1 *service.TaskList
		result2 error
	}
	taskListReturnsOnCall map[int]struct {
		result1 *service.TaskList
		result2 error
	}
	TaskListHistoryStub        func(context.Context, string) (*service.TaskList, error)
	taskListHistoryMutex       sync.RWMutex
	taskListHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskListHistoryReturns struct {
		result1 *service.TaskList
		result2 error
	}
	taskListHistoryReturnsOnCall map[int]struct {
		result1 *service.TaskList
		result2 error
	}
	TaskListTemplateStub        func(context.Context, string) (*service.Template, error)
	taskListTemplateMutex       sync.RWMutex
	taskListTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskListTemplateReturns struct {
		result1 *service.Template
		result2 error
	}
	taskListTemplateReturnsOnCall map[int]struct {
		result1 *service.Template
		result2 error
	}
	TaskTemplateStub        func(context.Context, string) (*service.Task, error)
	taskTemplateMutex       sync.RWMutex
	taskTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskTemplateReturns struct {
		result1 *service.Task
		result2 error
	}
	taskTemplateReturnsOnCall map[int]struct {
		result1 *service.Task
		result2 error
	}
	TaskTemplatesStub        func(context.Context, []string) (map[string]*service.Task, error)
	taskTemplatesMutex       sync.RWMutex
	taskTemplatesArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	taskTemplatesReturns struct {
		result1 map[string]*service.Task
		result2 error
	}
	taskTemplatesReturnsOnCall map[int]struct {
		result1 map[string]*service.Task
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) EventTask(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*service.EventTask, error) {
	fake.eventTaskMutex.Lock()
	ret, specificReturn := fake.eventTaskReturnsOnCall[len(fake.eventTaskArgsForCall)]
	fake.eventTaskArgsForCall = append(fake.eventTaskArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.EventTaskStub
	fakeReturns := fake.eventTaskReturns
	fake.recordInvocation("EventTask", []interface{}{arg1, arg2, arg3, arg4})
	fake.eventTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) EventTaskCallCount() int {
	fake.eventTaskMutex.RLock()
	defer fake.eventTaskMutex.RUnlock()
	return len(fake.eventTaskArgsForCall)
}

func (fake *FakeStorage) EventTaskCalls(stub func(context.Context, string, string, string) (*service.EventTask, error)) {
	fake.eventTaskMutex.Lock()
	defer fake.eventTaskMutex.Unlock()
	fake.EventTaskStub = stub
}

func (fake *FakeStorage) EventTaskArgsForCall(i int) (context.Context, string, string, string) {
	fake.eventTaskMutex.RLock()
	defer fake.eventTaskMutex.RUnlock()
	argsForCall := fake.eventTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStorage) EventTaskReturns(result1 *service.EventTask, result2 error) {
	fake.eventTaskMutex.Lock()
	defer fake.eventTaskMutex.Unlock()
	fake.EventTaskStub = nil
	fake.eventTaskReturns = struct {
		result1 *service.EventTask
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) EventTaskReturnsOnCall(i int, result1 *service.EventTask, result2 error) {
	fake.eventTaskMutex.Lock()
	defer fake.eventTaskMutex.Unlock()
	fake.EventTaskStub = nil
	if fake.eventTaskReturnsOnCall == nil {
		fake.eventTaskReturnsOnCall = make(map[int]struct {
			result1 *service.EventTask
			result2 error
		})
	}
	fake.eventTaskReturnsOnCall[i] = struct {
		result1 *service.EventTask
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetGroupTasks(arg1 context.Context, arg2 *service.Group) ([]*service.Task, error) {
	fake.getGroupTasksMutex.Lock()
	ret, specificReturn := fake.getGroupTasksReturnsOnCall[len(fake.getGroupTasksArgsForCall)]
	fake.getGroupTasksArgsForCall = append(fake.getGroupTasksArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Group
	}{arg1, arg2})
	stub := fake.GetGroupTasksStub
	fakeReturns := fake.getGroupTasksReturns
	fake.recordInvocation("GetGroupTasks", []interface{}{arg1, arg2})
	fake.getGroupTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetGroupTasksCallCount() int {
	fake.getGroupTasksMutex.RLock()
	defer fake.getGroupTasksMutex.RUnlock()
	return len(fake.getGroupTasksArgsForCall)
}

func (fake *FakeStorage) GetGroupTasksCalls(stub func(context.Context, *service.Group) ([]*service.Task, error)) {
	fake.getGroupTasksMutex.Lock()
	defer fake.getGroupTasksMutex.Unlock()
	fake.GetGroupTasksStub = stub
}

func (fake *FakeStorage) GetGroupTasksArgsForCall(i int) (context.Context, *service.Group) {
	fake.getGroupTasksMutex.RLock()
	defer fake.getGroupTasksMutex.RUnlock()
	argsForCall := fake.getGroupTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetGroupTasksReturns(result1 []*service.Task, result2 error) {
	fake.getGroupTasksMutex.Lock()
	defer fake.getGroupTasksMutex.Unlock()
	fake.GetGroupTasksStub = nil
	fake.getGroupTasksReturns = struct {
		result1 []*service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetGroupTasksReturnsOnCall(i int, result1 []*service.Task, result2 error) {
	fake.getGroupTasksMutex.Lock()
	defer fake.getGroupTasksMutex.Unlock()
	fake.GetGroupTasksStub = nil
	if fake.getGroupTasksReturnsOnCall == nil {
		fake.getGroupTasksReturnsOnCall = make(map[int]struct {
			result1 []*service.Task
			result2 error
		})
	}
	fake.getGroupTasksReturnsOnCall[i] = struct {
		result1 []*service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) SaveTaskHistory(arg1 context.Context, arg2 *service.Task) error {
	fake.saveTaskHistoryMutex.Lock()
	ret, specificReturn := fake.saveTaskHistoryReturnsOnCall[len(fake.saveTaskHistoryArgsForCall)]
	fake.saveTaskHistoryArgsForCall = append(fake.saveTaskHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 *service.Task
	}{arg1, arg2})
	stub := fake.SaveTaskHistoryStub
	fakeReturns := fake.saveTaskHistoryReturns
	fake.recordInvocation("SaveTaskHistory", []interface{}{arg1, arg2})
	fake.saveTaskHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SaveTaskHistoryCallCount() int {
	fake.saveTaskHistoryMutex.RLock()
	defer fake.saveTaskHistoryMutex.RUnlock()
	return len(fake.saveTaskHistoryArgsForCall)
}

func (fake *FakeStorage) SaveTaskHistoryCalls(stub func(context.Context, *service.Task) error) {
	fake.saveTaskHistoryMutex.Lock()
	defer fake.saveTaskHistoryMutex.Unlock()
	fake.SaveTaskHistoryStub = stub
}

func (fake *FakeStorage) SaveTaskHistoryArgsForCall(i int) (context.Context, *service.Task) {
	fake.saveTaskHistoryMutex.RLock()
	defer fake.saveTaskHistoryMutex.RUnlock()
	argsForCall := fake.saveTaskHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) SaveTaskHistoryReturns(result1 error) {
	fake.saveTaskHistoryMutex.Lock()
	defer fake.saveTaskHistoryMutex.Unlock()
	fake.SaveTaskHistoryStub = nil
	fake.saveTaskHistoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SaveTaskHistoryReturnsOnCall(i int, result1 error) {
	fake.saveTaskHistoryMutex.Lock()
	defer fake.saveTaskHistoryMutex.Unlock()
	fake.SaveTaskHistoryStub = nil
	if fake.saveTaskHistoryReturnsOnCall == nil {
		fake.saveTaskHistoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveTaskHistoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SaveTaskListHistory(arg1 context.Context, arg2 *service.TaskList) error {
	fake.saveTaskListHistoryMutex.Lock()
	ret, specificReturn := fake.saveTaskListHistoryReturnsOnCall[len(fake.saveTaskListHistoryArgsForCall)]
	fake.saveTaskListHistoryArgsForCall = append(fake.saveTaskListHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 *service.TaskList
	}{arg1, arg2})
	stub := fake.SaveTaskListHistoryStub
	fakeReturns := fake.saveTaskListHistoryReturns
	fake.recordInvocation("SaveTaskListHistory", []interface{}{arg1, arg2})
	fake.saveTaskListHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SaveTaskListHistoryCallCount() int {
	fake.saveTaskListHistoryMutex.RLock()
	defer fake.saveTaskListHistoryMutex.RUnlock()
	return len(fake.saveTaskListHistoryArgsForCall)
}

func (fake *FakeStorage) SaveTaskListHistoryCalls(stub func(context.Context, *service.TaskList) error) {
	fake.saveTaskListHistoryMutex.Lock()
	defer fake.saveTaskListHistoryMutex.Unlock()
	fake.SaveTaskListHistoryStub = stub
}

func (fake *FakeStorage) SaveTaskListHistoryArgsForCall(i int) (context.Context, *service.TaskList) {
	fake.saveTaskListHistoryMutex.RLock()
	defer fake.saveTaskListHistoryMutex.RUnlock()
	argsForCall := fake.saveTaskListHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) SaveTaskListHistoryReturns(result1 error) {
	fake.saveTaskListHistoryMutex.Lock()
	defer fake.saveTaskListHistoryMutex.Unlock()
	fake.SaveTaskListHistoryStub = nil
	fake.saveTaskListHistoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SaveTaskListHistoryReturnsOnCall(i int, result1 error) {
	fake.saveTaskListHistoryMutex.Lock()
	defer fake.saveTaskListHistoryMutex.Unlock()
	fake.SaveTaskListHistoryStub = nil
	if fake.saveTaskListHistoryReturnsOnCall == nil {
		fake.saveTaskListHistoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveTaskListHistoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Task(arg1 context.Context, arg2 string) (*service.Task, error) {
	fake.taskMutex.Lock()
	ret, specificReturn := fake.taskReturnsOnCall[len(fake.taskArgsForCall)]
	fake.taskArgsForCall = append(fake.taskArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskStub
	fakeReturns := fake.taskReturns
	fake.recordInvocation("Task", []interface{}{arg1, arg2})
	fake.taskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskCallCount() int {
	fake.taskMutex.RLock()
	defer fake.taskMutex.RUnlock()
	return len(fake.taskArgsForCall)
}

func (fake *FakeStorage) TaskCalls(stub func(context.Context, string) (*service.Task, error)) {
	fake.taskMutex.Lock()
	defer fake.taskMutex.Unlock()
	fake.TaskStub = stub
}

func (fake *FakeStorage) TaskArgsForCall(i int) (context.Context, string) {
	fake.taskMutex.RLock()
	defer fake.taskMutex.RUnlock()
	argsForCall := fake.taskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskReturns(result1 *service.Task, result2 error) {
	fake.taskMutex.Lock()
	defer fake.taskMutex.Unlock()
	fake.TaskStub = nil
	fake.taskReturns = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskReturnsOnCall(i int, result1 *service.Task, result2 error) {
	fake.taskMutex.Lock()
	defer fake.taskMutex.Unlock()
	fake.TaskStub = nil
	if fake.taskReturnsOnCall == nil {
		fake.taskReturnsOnCall = make(map[int]struct {
			result1 *service.Task
			result2 error
		})
	}
	fake.taskReturnsOnCall[i] = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskHistory(arg1 context.Context, arg2 string) (*service.Task, error) {
	fake.taskHistoryMutex.Lock()
	ret, specificReturn := fake.taskHistoryReturnsOnCall[len(fake.taskHistoryArgsForCall)]
	fake.taskHistoryArgsForCall = append(fake.taskHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskHistoryStub
	fakeReturns := fake.taskHistoryReturns
	fake.recordInvocation("TaskHistory", []interface{}{arg1, arg2})
	fake.taskHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskHistoryCallCount() int {
	fake.taskHistoryMutex.RLock()
	defer fake.taskHistoryMutex.RUnlock()
	return len(fake.taskHistoryArgsForCall)
}

func (fake *FakeStorage) TaskHistoryCalls(stub func(context.Context, string) (*service.Task, error)) {
	fake.taskHistoryMutex.Lock()
	defer fake.taskHistoryMutex.Unlock()
	fake.TaskHistoryStub = stub
}

func (fake *FakeStorage) TaskHistoryArgsForCall(i int) (context.Context, string) {
	fake.taskHistoryMutex.RLock()
	defer fake.taskHistoryMutex.RUnlock()
	argsForCall := fake.taskHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskHistoryReturns(result1 *service.Task, result2 error) {
	fake.taskHistoryMutex.Lock()
	defer fake.taskHistoryMutex.Unlock()
	fake.TaskHistoryStub = nil
	fake.taskHistoryReturns = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskHistoryReturnsOnCall(i int, result1 *service.Task, result2 error) {
	fake.taskHistoryMutex.Lock()
	defer fake.taskHistoryMutex.Unlock()
	fake.TaskHistoryStub = nil
	if fake.taskHistoryReturnsOnCall == nil {
		fake.taskHistoryReturnsOnCall = make(map[int]struct {
			result1 *service.Task
			result2 error
		})
	}
	fake.taskHistoryReturnsOnCall[i] = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskList(arg1 context.Context, arg2 string) (*service.TaskList, error) {
	fake.taskListMutex.Lock()
	ret, specificReturn := fake.taskListReturnsOnCall[len(fake.taskListArgsForCall)]
	fake.taskListArgsForCall = append(fake.taskListArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskListStub
	fakeReturns := fake.taskListReturns
	fake.recordInvocation("TaskList", []interface{}{arg1, arg2})
	fake.taskListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskListCallCount() int {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	return len(fake.taskListArgsForCall)
}

func (fake *FakeStorage) TaskListCalls(stub func(context.Context, string) (*service.TaskList, error)) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = stub
}

func (fake *FakeStorage) TaskListArgsForCall(i int) (context.Context, string) {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	argsForCall := fake.taskListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskListReturns(result1 *service.TaskList, result2 error) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = nil
	fake.taskListReturns = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskListReturnsOnCall(i int, result1 *service.TaskList, result2 error) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = nil
	if fake.taskListReturnsOnCall == nil {
		fake.taskListReturnsOnCall = make(map[int]struct {
			result1 *service.TaskList
			result2 error
		})
	}
	fake.taskListReturnsOnCall[i] = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskListHistory(arg1 context.Context, arg2 string) (*service.TaskList, error) {
	fake.taskListHistoryMutex.Lock()
	ret, specificReturn := fake.taskListHistoryReturnsOnCall[len(fake.taskListHistoryArgsForCall)]
	fake.taskListHistoryArgsForCall = append(fake.taskListHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskListHistoryStub
	fakeReturns := fake.taskListHistoryReturns
	fake.recordInvocation("TaskListHistory", []interface{}{arg1, arg2})
	fake.taskListHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskListHistoryCallCount() int {
	fake.taskListHistoryMutex.RLock()
	defer fake.taskListHistoryMutex.RUnlock()
	return len(fake.taskListHistoryArgsForCall)
}

func (fake *FakeStorage) TaskListHistoryCalls(stub func(context.Context, string) (*service.TaskList, error)) {
	fake.taskListHistoryMutex.Lock()
	defer fake.taskListHistoryMutex.Unlock()
	fake.TaskListHistoryStub = stub
}

func (fake *FakeStorage) TaskListHistoryArgsForCall(i int) (context.Context, string) {
	fake.taskListHistoryMutex.RLock()
	defer fake.taskListHistoryMutex.RUnlock()
	argsForCall := fake.taskListHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskListHistoryReturns(result1 *service.TaskList, result2 error) {
	fake.taskListHistoryMutex.Lock()
	defer fake.taskListHistoryMutex.Unlock()
	fake.TaskListHistoryStub = nil
	fake.taskListHistoryReturns = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskListHistoryReturnsOnCall(i int, result1 *service.TaskList, result2 error) {
	fake.taskListHistoryMutex.Lock()
	defer fake.taskListHistoryMutex.Unlock()
	fake.TaskListHistoryStub = nil
	if fake.taskListHistoryReturnsOnCall == nil {
		fake.taskListHistoryReturnsOnCall = make(map[int]struct {
			result1 *service.TaskList
			result2 error
		})
	}
	fake.taskListHistoryReturnsOnCall[i] = struct {
		result1 *service.TaskList
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskListTemplate(arg1 context.Context, arg2 string) (*service.Template, error) {
	fake.taskListTemplateMutex.Lock()
	ret, specificReturn := fake.taskListTemplateReturnsOnCall[len(fake.taskListTemplateArgsForCall)]
	fake.taskListTemplateArgsForCall = append(fake.taskListTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskListTemplateStub
	fakeReturns := fake.taskListTemplateReturns
	fake.recordInvocation("TaskListTemplate", []interface{}{arg1, arg2})
	fake.taskListTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskListTemplateCallCount() int {
	fake.taskListTemplateMutex.RLock()
	defer fake.taskListTemplateMutex.RUnlock()
	return len(fake.taskListTemplateArgsForCall)
}

func (fake *FakeStorage) TaskListTemplateCalls(stub func(context.Context, string) (*service.Template, error)) {
	fake.taskListTemplateMutex.Lock()
	defer fake.taskListTemplateMutex.Unlock()
	fake.TaskListTemplateStub = stub
}

func (fake *FakeStorage) TaskListTemplateArgsForCall(i int) (context.Context, string) {
	fake.taskListTemplateMutex.RLock()
	defer fake.taskListTemplateMutex.RUnlock()
	argsForCall := fake.taskListTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskListTemplateReturns(result1 *service.Template, result2 error) {
	fake.taskListTemplateMutex.Lock()
	defer fake.taskListTemplateMutex.Unlock()
	fake.TaskListTemplateStub = nil
	fake.taskListTemplateReturns = struct {
		result1 *service.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskListTemplateReturnsOnCall(i int, result1 *service.Template, result2 error) {
	fake.taskListTemplateMutex.Lock()
	defer fake.taskListTemplateMutex.Unlock()
	fake.TaskListTemplateStub = nil
	if fake.taskListTemplateReturnsOnCall == nil {
		fake.taskListTemplateReturnsOnCall = make(map[int]struct {
			result1 *service.Template
			result2 error
		})
	}
	fake.taskListTemplateReturnsOnCall[i] = struct {
		result1 *service.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskTemplate(arg1 context.Context, arg2 string) (*service.Task, error) {
	fake.taskTemplateMutex.Lock()
	ret, specificReturn := fake.taskTemplateReturnsOnCall[len(fake.taskTemplateArgsForCall)]
	fake.taskTemplateArgsForCall = append(fake.taskTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.TaskTemplateStub
	fakeReturns := fake.taskTemplateReturns
	fake.recordInvocation("TaskTemplate", []interface{}{arg1, arg2})
	fake.taskTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskTemplateCallCount() int {
	fake.taskTemplateMutex.RLock()
	defer fake.taskTemplateMutex.RUnlock()
	return len(fake.taskTemplateArgsForCall)
}

func (fake *FakeStorage) TaskTemplateCalls(stub func(context.Context, string) (*service.Task, error)) {
	fake.taskTemplateMutex.Lock()
	defer fake.taskTemplateMutex.Unlock()
	fake.TaskTemplateStub = stub
}

func (fake *FakeStorage) TaskTemplateArgsForCall(i int) (context.Context, string) {
	fake.taskTemplateMutex.RLock()
	defer fake.taskTemplateMutex.RUnlock()
	argsForCall := fake.taskTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskTemplateReturns(result1 *service.Task, result2 error) {
	fake.taskTemplateMutex.Lock()
	defer fake.taskTemplateMutex.Unlock()
	fake.TaskTemplateStub = nil
	fake.taskTemplateReturns = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskTemplateReturnsOnCall(i int, result1 *service.Task, result2 error) {
	fake.taskTemplateMutex.Lock()
	defer fake.taskTemplateMutex.Unlock()
	fake.TaskTemplateStub = nil
	if fake.taskTemplateReturnsOnCall == nil {
		fake.taskTemplateReturnsOnCall = make(map[int]struct {
			result1 *service.Task
			result2 error
		})
	}
	fake.taskTemplateReturnsOnCall[i] = struct {
		result1 *service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskTemplates(arg1 context.Context, arg2 []string) (map[string]*service.Task, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.taskTemplatesMutex.Lock()
	ret, specificReturn := fake.taskTemplatesReturnsOnCall[len(fake.taskTemplatesArgsForCall)]
	fake.taskTemplatesArgsForCall = append(fake.taskTemplatesArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.TaskTemplatesStub
	fakeReturns := fake.taskTemplatesReturns
	fake.recordInvocation("TaskTemplates", []interface{}{arg1, arg2Copy})
	fake.taskTemplatesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) TaskTemplatesCallCount() int {
	fake.taskTemplatesMutex.RLock()
	defer fake.taskTemplatesMutex.RUnlock()
	return len(fake.taskTemplatesArgsForCall)
}

func (fake *FakeStorage) TaskTemplatesCalls(stub func(context.Context, []string) (map[string]*service.Task, error)) {
	fake.taskTemplatesMutex.Lock()
	defer fake.taskTemplatesMutex.Unlock()
	fake.TaskTemplatesStub = stub
}

func (fake *FakeStorage) TaskTemplatesArgsForCall(i int) (context.Context, []string) {
	fake.taskTemplatesMutex.RLock()
	defer fake.taskTemplatesMutex.RUnlock()
	argsForCall := fake.taskTemplatesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) TaskTemplatesReturns(result1 map[string]*service.Task, result2 error) {
	fake.taskTemplatesMutex.Lock()
	defer fake.taskTemplatesMutex.Unlock()
	fake.TaskTemplatesStub = nil
	fake.taskTemplatesReturns = struct {
		result1 map[string]*service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) TaskTemplatesReturnsOnCall(i int, result1 map[string]*service.Task, result2 error) {
	fake.taskTemplatesMutex.Lock()
	defer fake.taskTemplatesMutex.Unlock()
	fake.TaskTemplatesStub = nil
	if fake.taskTemplatesReturnsOnCall == nil {
		fake.taskTemplatesReturnsOnCall = make(map[int]struct {
			result1 map[string]*service.Task
			result2 error
		})
	}
	fake.taskTemplatesReturnsOnCall[i] = struct {
		result1 map[string]*service.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.eventTaskMutex.RLock()
	defer fake.eventTaskMutex.RUnlock()
	fake.getGroupTasksMutex.RLock()
	defer fake.getGroupTasksMutex.RUnlock()
	fake.saveTaskHistoryMutex.RLock()
	defer fake.saveTaskHistoryMutex.RUnlock()
	fake.saveTaskListHistoryMutex.RLock()
	defer fake.saveTaskListHistoryMutex.RUnlock()
	fake.taskMutex.RLock()
	defer fake.taskMutex.RUnlock()
	fake.taskHistoryMutex.RLock()
	defer fake.taskHistoryMutex.RUnlock()
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	fake.taskListHistoryMutex.RLock()
	defer fake.taskListHistoryMutex.RUnlock()
	fake.taskListTemplateMutex.RLock()
	defer fake.taskListTemplateMutex.RUnlock()
	fake.taskTemplateMutex.RLock()
	defer fake.taskTemplateMutex.RUnlock()
	fake.taskTemplatesMutex.RLock()
	defer fake.taskTemplatesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.Storage = new(FakeStorage)
